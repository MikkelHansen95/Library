SET search_path TO libraryschema;

CREATE OR REPLACE FUNCTION getclientloansize(loanid int) RETURNS integer as $$
	DECLARE
	 singleresult integer;
	BEGIN
	 SELECT clienttype.loanlength into singleresult FROM loans
	  INNER JOIN client ON loans.clientid = client.id 
	  INNER JOIN clienttype ON client.type = clienttype.id 
	  WHERE loans.id = loanid;
	  RETURN singleresult;
	END; 
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION createenddate() RETURNS TRIGGER as $$
 DECLARE
 	tempval integer;
	loanid integer := NEW.id;
 BEGIN
 	SELECT getclientloansize(loanid) INTO tempval;
	IF (tempval > 0) THEN
		UPDATE loans SET enddate = NEW.startdate + tempVal WHERE id = loanid;
	ELSE
		RAISE EXCEPTION 'DOES NOT WORK val: %  --- id:  %', tempval,NEW.id;
	END IF;
   RETURN NEW;
 END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enddatecreation
AFTER INSERT ON loans
FOR EACH ROW
EXECUTE PROCEDURE createenddate();

CREATE OR REPLACE FUNCTION updateusernadbookinstance() RETURNS TRIGGER as $$
 DECLARE
	loanid integer := NEW.id;
	loanc int;
	cid int;
	loancap int;
	loansbookid int;
	bookinstavailable boolean;
 BEGIN
 	SELECT client.loancount, clienttype.loancapacity, loans.instanceid, client.id, bookinstance.available into loanc,loancap,loansbookid,cid,bookinstavailable FROM loans
	  INNER JOIN client ON loans.clientid = client.id 
	  INNER JOIN clienttype ON client.type = clienttype.id
	  INNER JOIN bookinstance ON loans.instanceid = bookinstance.id
	  WHERE loans.id = loanid;
	
	IF bookinstavailable = false THEN
		RAISE EXCEPTION 'BOOK IS ALREADY ON LOAN';
	END IF;
	IF loanc < loancap THEN
		UPDATE client SET loancount = loancount + 1 WHERE id = cid;
		UPDATE bookinstance SET available = false, location = cid WHERE id = loansbookid;
	ELSE
		RAISE EXCEPTION 'YOU HAVE TOO MANY BOOKS ON LOAN, YOU NEED TO RETURN ONE BEFORE YOU CAN BORROW AGAIN';
	END IF;
   RETURN NEW;
 END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER updatebookandclienttrigger
AFTER INSERT ON loans
FOR EACH ROW
EXECUTE PROCEDURE updateusernadbookinstance();

 SELECT * FROM loans
	  INNER JOIN client ON loans.clientid = client.id 
	  INNER JOIN clienttype ON client.type = clienttype.id 
	  INNER JOIN bookinstance ON loans.instanceid = bookinstance.id
	  WHERE loans.id = 78;
	  
INNER JOIN client ON loans.clientid = client.id 
INNER JOIN clienttype ON client.type = clienttype.id
INNER JOIN bookinstance ON loans.instanceid = bookinstance.id;

UPDATE loans SET activeloan = false WHERE id = 84;

INSERT INTO loans (instanceid,clientid,startdate)
VALUES (3,3,NOW());


CREATE OR REPLACE FUNCTION bookavailability(isbnpara bigint) RETURNS integer as $$
	DECLARE
	 singleresult integer; 
	BEGIN
     SELECT COUNT(*) into singleresult FROM BOOKINSTANCE WHERE ISBN = $1 and available = true;
	RETURN singleresult;
	END;
	$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION getclientloansize(loanid int) RETURNS integer as $$
	DECLARE
	 singleresult integer;
	BEGIN
	 SELECT clienttype.loanlength into singleresult FROM loans
	  INNER JOIN client ON loans.clientid = client.id 
	  INNER JOIN clienttype ON client.type = clienttype.id 
	  WHERE loans.id = loanid;
	  RETURN singleresult;
	END; 
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION returnbook() RETURNS TRIGGER as $$
 DECLARE
	loanid integer := NEW.id;
	loanc int;
	cid int;
	loansbookid int;
	lenddate date;
	aloan boolean;
 BEGIN
 	SELECT client.loancount, loans.instanceid, client.id, loans.enddate,loans.activeloan into loanc,loansbookid,cid,lenddate,aloan FROM loans
	  INNER JOIN client ON loans.clientid = client.id 
	  INNER JOIN clienttype ON client.type = clienttype.id
	  INNER JOIN bookinstance ON loans.instanceid = bookinstance.id
	  WHERE loans.id = loanid;
	IF (loanc >= 0) THEN
		UPDATE client SET loancount = loancount - 1 WHERE id = cid;
		UPDATE bookinstance SET available = true, location = null WHERE id = loansbookid;
	ELSE
		RAISE EXCEPTION 'YOU DONT HAVE ANY LOANS';
	END IF;
	IF lenddate < NOW() THEN
		RAISE NOTICE 'YOU HAVE RETURNED THE BOOK TOO LATE';
		UPDATE loans SET overdue = true WHERE id = loanid;
	END IF;
   RETURN NEW;
 END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bookreturn
AFTER UPDATE ON loans
FOR EACH ROW
EXECUTE PROCEDURE returnbook();

CREATE OR REPLACE FUNCTION returnbookfunc(loanid int, bookinst int) RETURNS void as $$
	BEGIN
	UPDATE loans SET activeloan = false WHERE id = loanid and instanceid = bookinst;
	END; 
$$ LANGUAGE plpgsql;

DROP PROCEDURE insert_loan;

CREATE PROCEDURE insert_loan(instance_id integer, client_id integer) LANGUAGE SQL AS $$

	INSERT INTO loans (instanceid,clientid) VALUES (instance_id,client_id);
	
$$;

CREATE PROCEDURE insert_loan(instance_id integer, client_id integer) LANGUAGE SQL AS $$
 DECLARE
	loanid integer := NEW.id;	loanc int;	cid int;	loancap int;	loansbookid int;	bookinstavailable boolean; loanlength int;
	calculateenddate date;
 BEGIN
 	SELECT client.loancount, clienttype.loancapacity, loans.instanceid, client.id, bookinstance.available, clienttype.loanlength
	  into loanc,loancap,loansbookid,cid,bookinstavailable, loanlength FROM loans
	  INNER JOIN client ON loans.clientid = client.id 
	  INNER JOIN clienttype ON client.type = clienttype.id
	  INNER JOIN bookinstance ON loans.instanceid = bookinstance.id
	  WHERE loans.id = loanid;
	IF bookinstavailable = false THEN
		RAISE EXCEPTION 'BOOK IS ALREADY ON LOAN';
	END IF;
	IF loanc < loancap THEN
		calculateenddate := NOW() + loanlength;
		INSERT INTO loans (instanceid,clientid,startdate,enddate) VALUES (instance_id,client_id,NOW(),calculateenddate)
		 COMMIT;
		UPDATE client SET loancount = loancount + 1 WHERE id = cid;
		 COMMIT;
		UPDATE bookinstance SET available = false, location = cid WHERE id = loansbookid;
		 COMMIT;
	ELSE
		RAISE EXCEPTION 'YOU HAVE TOO MANY BOOKS ON LOAN, YOU NEED TO RETURN ONE BEFORE YOU CAN BORROW AGAIN';
	END IF;
   RETURN NEW;
 END;
$$ LANGUAGE plpgsql;

select * from loans;

CREATE PROCEDURE return_loan(loanid integer) LANGUAGE SQL AS $$
	UPDATE loans SET activeloan = false where id = loanid;
$$;


SELECT COUNT(*) AS loanc FROM loans WHERE clientid = 2 and activeloan = true;

